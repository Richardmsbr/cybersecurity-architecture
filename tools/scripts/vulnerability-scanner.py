#!/usr/bin/env python3
"""
Vulnerability Scanner
Performs security scanning on web applications and infrastructure.

Usage:
    python vulnerability-scanner.py --target https://example.com --scan-type web
    python vulnerability-scanner.py --target 192.168.1.0/24 --scan-type network
"""

import argparse
import json
import re
import socket
import ssl
import sys
import urllib.request
import urllib.error
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from concurrent.futures import ThreadPoolExecutor, as_completed

@dataclass
class Finding:
    """Security finding dataclass."""
    severity: str
    category: str
    title: str
    description: str
    remediation: str
    evidence: str = ""
    cvss: float = 0.0
    cve: str = ""

class Colors:
    """ANSI color codes."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def log(level: str, message: str) -> None:
    """Log message with color."""
    colors = {
        'INFO': Colors.BLUE,
        'PASS': Colors.GREEN,
        'WARN': Colors.YELLOW,
        'FAIL': Colors.RED,
        'CRITICAL': Colors.RED + Colors.BOLD
    }
    color = colors.get(level, '')
    print(f"{color}[{level}]{Colors.ENDC} {message}")

class WebScanner:
    """Web application security scanner."""

    def __init__(self, target: str, timeout: int = 10):
        self.target = target.rstrip('/')
        self.timeout = timeout
        self.findings: List[Finding] = []

    def scan(self) -> List[Finding]:
        """Run all web security checks."""
        log('INFO', f"Starting web scan on {self.target}")

        self.check_ssl_tls()
        self.check_security_headers()
        self.check_common_vulnerabilities()
        self.check_information_disclosure()
        self.check_sensitive_files()

        return self.findings

    def _make_request(self, path: str = "", method: str = "GET",
                      headers: Dict = None) -> Tuple[int, Dict, str]:
        """Make HTTP request and return status, headers, body."""
        url = f"{self.target}{path}"
        headers = headers or {}
        headers['User-Agent'] = 'SecurityScanner/1.0'

        try:
            req = urllib.request.Request(url, headers=headers, method=method)
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            with urllib.request.urlopen(req, timeout=self.timeout, context=context) as response:
                return response.status, dict(response.headers), response.read().decode('utf-8', errors='ignore')
        except urllib.error.HTTPError as e:
            return e.code, dict(e.headers), ""
        except Exception as e:
            return 0, {}, str(e)

    def check_ssl_tls(self) -> None:
        """Check SSL/TLS configuration."""
        log('INFO', "Checking SSL/TLS configuration...")

        if not self.target.startswith('https://'):
            self.findings.append(Finding(
                severity="HIGH",
                category="Transport Security",
                title="HTTPS Not Enforced",
                description="The application is not using HTTPS",
                remediation="Enable HTTPS and redirect all HTTP traffic to HTTPS"
            ))
            return

        try:
            hostname = self.target.replace('https://', '').split('/')[0]
            context = ssl.create_default_context()

            with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    protocol = ssock.version()
                    cipher = ssock.cipher()

                    # Check protocol version
                    if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        self.findings.append(Finding(
                            severity="HIGH",
                            category="Transport Security",
                            title=f"Weak TLS Version: {protocol}",
                            description=f"Server supports deprecated {protocol}",
                            remediation="Disable TLS versions below 1.2"
                        ))
                    else:
                        log('PASS', f"TLS version: {protocol}")

                    # Check cipher strength
                    if cipher and cipher[2] < 128:
                        self.findings.append(Finding(
                            severity="MEDIUM",
                            category="Transport Security",
                            title="Weak Cipher Suite",
                            description=f"Cipher {cipher[0]} uses {cipher[2]}-bit encryption",
                            remediation="Configure server to use strong cipher suites (256-bit)"
                        ))

                    # Check certificate expiration
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_left = (not_after - datetime.now()).days

                        if days_left < 0:
                            self.findings.append(Finding(
                                severity="CRITICAL",
                                category="Transport Security",
                                title="Expired SSL Certificate",
                                description=f"Certificate expired {abs(days_left)} days ago",
                                remediation="Renew the SSL certificate immediately"
                            ))
                        elif days_left < 30:
                            self.findings.append(Finding(
                                severity="MEDIUM",
                                category="Transport Security",
                                title="SSL Certificate Expiring Soon",
                                description=f"Certificate expires in {days_left} days",
                                remediation="Renew the SSL certificate before expiration"
                            ))
                        else:
                            log('PASS', f"Certificate valid for {days_left} days")

        except ssl.SSLError as e:
            self.findings.append(Finding(
                severity="HIGH",
                category="Transport Security",
                title="SSL Certificate Error",
                description=str(e),
                remediation="Fix SSL certificate configuration"
            ))
        except Exception as e:
            log('WARN', f"Could not check SSL: {e}")

    def check_security_headers(self) -> None:
        """Check security headers."""
        log('INFO', "Checking security headers...")

        status, headers, _ = self._make_request()
        if status == 0:
            log('WARN', "Could not connect to target")
            return

        required_headers = {
            'Strict-Transport-Security': {
                'severity': 'HIGH',
                'description': 'HSTS header is missing',
                'remediation': 'Add Strict-Transport-Security header with max-age=31536000'
            },
            'X-Content-Type-Options': {
                'severity': 'MEDIUM',
                'description': 'X-Content-Type-Options header is missing',
                'remediation': 'Add X-Content-Type-Options: nosniff header'
            },
            'X-Frame-Options': {
                'severity': 'MEDIUM',
                'description': 'X-Frame-Options header is missing (clickjacking protection)',
                'remediation': 'Add X-Frame-Options: DENY or SAMEORIGIN header'
            },
            'Content-Security-Policy': {
                'severity': 'MEDIUM',
                'description': 'Content-Security-Policy header is missing',
                'remediation': 'Implement Content-Security-Policy header'
            },
            'X-XSS-Protection': {
                'severity': 'LOW',
                'description': 'X-XSS-Protection header is missing',
                'remediation': 'Add X-XSS-Protection: 1; mode=block header'
            },
            'Referrer-Policy': {
                'severity': 'LOW',
                'description': 'Referrer-Policy header is missing',
                'remediation': 'Add Referrer-Policy: strict-origin-when-cross-origin header'
            }
        }

        # Normalize header names (case-insensitive)
        headers_lower = {k.lower(): v for k, v in headers.items()}

        for header, config in required_headers.items():
            if header.lower() not in headers_lower:
                self.findings.append(Finding(
                    severity=config['severity'],
                    category="Security Headers",
                    title=f"Missing {header}",
                    description=config['description'],
                    remediation=config['remediation']
                ))
            else:
                log('PASS', f"{header} header present")

        # Check for information disclosure headers
        disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
        for header in disclosure_headers:
            if header.lower() in headers_lower:
                self.findings.append(Finding(
                    severity="LOW",
                    category="Information Disclosure",
                    title=f"Server Version Disclosure: {header}",
                    description=f"{header} header reveals: {headers_lower[header.lower()]}",
                    remediation=f"Remove or obfuscate the {header} header"
                ))

    def check_common_vulnerabilities(self) -> None:
        """Check for common web vulnerabilities."""
        log('INFO', "Checking for common vulnerabilities...")

        # Test for XSS reflection
        xss_payloads = [
            "<script>alert(1)</script>",
            "'\"><img src=x onerror=alert(1)>",
            "javascript:alert(1)"
        ]

        test_params = ['q', 'search', 'query', 'id', 'name', 'page']

        for param in test_params:
            for payload in xss_payloads:
                status, headers, body = self._make_request(f"?{param}={urllib.parse.quote(payload)}")
                if payload in body:
                    self.findings.append(Finding(
                        severity="HIGH",
                        category="Injection",
                        title="Potential Reflected XSS",
                        description=f"XSS payload reflected in response via parameter '{param}'",
                        remediation="Implement proper output encoding and Content-Security-Policy",
                        evidence=f"Parameter: {param}, Payload: {payload[:50]}..."
                    ))
                    break

        # Test for SQL injection indicators
        sql_payloads = ["'", "\"", "1' OR '1'='1", "1 OR 1=1", "'; DROP TABLE users;--"]
        sql_errors = [
            "sql syntax", "mysql", "postgresql", "sqlite", "oracle",
            "ORA-", "PG::", "microsoft sql", "syntax error",
            "unclosed quotation", "quoted string not properly terminated"
        ]

        for param in test_params:
            for payload in sql_payloads:
                status, headers, body = self._make_request(f"?{param}={urllib.parse.quote(payload)}")
                body_lower = body.lower()
                for error in sql_errors:
                    if error.lower() in body_lower:
                        self.findings.append(Finding(
                            severity="CRITICAL",
                            category="Injection",
                            title="Potential SQL Injection",
                            description=f"SQL error message detected via parameter '{param}'",
                            remediation="Use parameterized queries and prepared statements",
                            evidence=f"Parameter: {param}, Error indicator: {error}"
                        ))
                        break

    def check_information_disclosure(self) -> None:
        """Check for information disclosure."""
        log('INFO', "Checking for information disclosure...")

        # Check common error pages
        error_paths = ['/404', '/500', '/error', '/debug', '/trace']
        for path in error_paths:
            status, headers, body = self._make_request(path)

            # Look for stack traces
            stack_indicators = ['Traceback', 'at line', 'Exception', 'Stack trace',
                              'NullPointerException', 'at java.', 'at org.']
            for indicator in stack_indicators:
                if indicator in body:
                    self.findings.append(Finding(
                        severity="MEDIUM",
                        category="Information Disclosure",
                        title="Stack Trace Exposed",
                        description=f"Application exposes stack trace at {path}",
                        remediation="Configure custom error pages and disable debug mode"
                    ))
                    break

    def check_sensitive_files(self) -> None:
        """Check for sensitive files exposure."""
        log('INFO', "Checking for sensitive files...")

        sensitive_paths = [
            ('/.git/config', 'Git configuration'),
            ('/.env', 'Environment variables'),
            ('/config.php', 'PHP configuration'),
            ('/wp-config.php', 'WordPress configuration'),
            ('/web.config', 'IIS configuration'),
            ('/.htaccess', 'Apache configuration'),
            ('/phpinfo.php', 'PHP info page'),
            ('/server-status', 'Apache server status'),
            ('/elmah.axd', 'ELMAH error log'),
            ('/.svn/entries', 'SVN metadata'),
            ('/backup.sql', 'Database backup'),
            ('/dump.sql', 'Database dump'),
            ('/.DS_Store', 'macOS metadata'),
            ('/crossdomain.xml', 'Flash cross-domain policy'),
            ('/clientaccesspolicy.xml', 'Silverlight policy'),
            ('/swagger.json', 'API documentation'),
            ('/api-docs', 'API documentation'),
            ('/graphql', 'GraphQL endpoint'),
            ('/.well-known/security.txt', 'Security policy')
        ]

        for path, description in sensitive_paths:
            status, headers, body = self._make_request(path)

            if status == 200 and len(body) > 0:
                self.findings.append(Finding(
                    severity="MEDIUM" if 'config' in path.lower() or '.env' in path else "LOW",
                    category="Sensitive File Exposure",
                    title=f"Exposed: {description}",
                    description=f"Sensitive file accessible at {path}",
                    remediation=f"Restrict access to {path} or remove from web root"
                ))


class NetworkScanner:
    """Network security scanner."""

    def __init__(self, target: str, timeout: int = 2):
        self.target = target
        self.timeout = timeout
        self.findings: List[Finding] = []
        self.common_ports = [
            (21, 'FTP'), (22, 'SSH'), (23, 'Telnet'), (25, 'SMTP'),
            (53, 'DNS'), (80, 'HTTP'), (110, 'POP3'), (111, 'RPC'),
            (135, 'MSRPC'), (139, 'NetBIOS'), (143, 'IMAP'), (443, 'HTTPS'),
            (445, 'SMB'), (993, 'IMAPS'), (995, 'POP3S'), (1433, 'MSSQL'),
            (1521, 'Oracle'), (3306, 'MySQL'), (3389, 'RDP'), (5432, 'PostgreSQL'),
            (5900, 'VNC'), (6379, 'Redis'), (8080, 'HTTP-Alt'), (8443, 'HTTPS-Alt'),
            (27017, 'MongoDB')
        ]

    def scan(self) -> List[Finding]:
        """Run network security checks."""
        log('INFO', f"Starting network scan on {self.target}")

        open_ports = self.scan_ports()
        self.analyze_ports(open_ports)

        return self.findings

    def scan_ports(self) -> List[Tuple[int, str]]:
        """Scan for open ports."""
        log('INFO', "Scanning ports...")
        open_ports = []

        def check_port(port_info):
            port, service = port_info
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                result = sock.connect_ex((self.target, port))
                sock.close()
                if result == 0:
                    return (port, service)
            except:
                pass
            return None

        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(check_port, port_info): port_info
                      for port_info in self.common_ports}

            for future in as_completed(futures):
                result = future.result()
                if result:
                    open_ports.append(result)
                    log('INFO', f"Port {result[0]}/{result[1]} is open")

        return open_ports

    def analyze_ports(self, open_ports: List[Tuple[int, str]]) -> None:
        """Analyze open ports for security issues."""

        dangerous_services = {
            23: ('Telnet', 'CRITICAL', 'Telnet transmits data in plaintext'),
            21: ('FTP', 'HIGH', 'FTP transmits credentials in plaintext'),
            135: ('MSRPC', 'HIGH', 'RPC can be exploited for remote attacks'),
            139: ('NetBIOS', 'HIGH', 'NetBIOS exposes system information'),
            445: ('SMB', 'HIGH', 'SMB is commonly targeted by malware'),
            3389: ('RDP', 'HIGH', 'RDP is frequently targeted for brute force'),
            5900: ('VNC', 'HIGH', 'VNC may have weak authentication'),
            6379: ('Redis', 'CRITICAL', 'Redis often has no authentication'),
            27017: ('MongoDB', 'CRITICAL', 'MongoDB may be unauthenticated'),
            111: ('RPC', 'MEDIUM', 'RPC can expose service information')
        }

        for port, service in open_ports:
            if port in dangerous_services:
                svc_name, severity, description = dangerous_services[port]
                self.findings.append(Finding(
                    severity=severity,
                    category="Network Security",
                    title=f"Dangerous Service Exposed: {svc_name}",
                    description=f"{description}. Port {port} is open.",
                    remediation=f"Restrict access to port {port} or disable the service"
                ))


def generate_report(findings: List[Finding], output_format: str = "text") -> str:
    """Generate security report."""

    if output_format == "json":
        return json.dumps([asdict(f) for f in findings], indent=2)

    # Text report
    report = []
    report.append("\n" + "=" * 60)
    report.append("         SECURITY SCAN REPORT")
    report.append("=" * 60)
    report.append(f"\nScan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report.append(f"Total Findings: {len(findings)}")

    # Count by severity
    severity_count = {}
    for f in findings:
        severity_count[f.severity] = severity_count.get(f.severity, 0) + 1

    report.append("\nFindings by Severity:")
    for sev in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
        if sev in severity_count:
            report.append(f"  {sev}: {severity_count[sev]}")

    # Detailed findings
    for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
        sev_findings = [f for f in findings if f.severity == severity]
        if sev_findings:
            report.append(f"\n{'=' * 60}")
            report.append(f" {severity} SEVERITY FINDINGS")
            report.append("=" * 60)

            for i, finding in enumerate(sev_findings, 1):
                report.append(f"\n[{i}] {finding.title}")
                report.append(f"    Category: {finding.category}")
                report.append(f"    Description: {finding.description}")
                if finding.evidence:
                    report.append(f"    Evidence: {finding.evidence}")
                report.append(f"    Remediation: {finding.remediation}")

    report.append("\n" + "=" * 60)
    report.append("         END OF REPORT")
    report.append("=" * 60 + "\n")

    return "\n".join(report)


def main():
    parser = argparse.ArgumentParser(
        description="Security Vulnerability Scanner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --target https://example.com --scan-type web
  %(prog)s --target 192.168.1.100 --scan-type network
  %(prog)s --target https://api.example.com --scan-type web --output json
        """
    )

    parser.add_argument('--target', '-t', required=True, help='Target URL or IP address')
    parser.add_argument('--scan-type', '-s', choices=['web', 'network', 'all'],
                       default='web', help='Type of scan to perform')
    parser.add_argument('--output', '-o', choices=['text', 'json'],
                       default='text', help='Output format')
    parser.add_argument('--timeout', type=int, default=10, help='Connection timeout in seconds')

    args = parser.parse_args()

    all_findings = []

    if args.scan_type in ['web', 'all']:
        scanner = WebScanner(args.target, args.timeout)
        all_findings.extend(scanner.scan())

    if args.scan_type in ['network', 'all']:
        # Extract host from URL if needed
        host = args.target
        if '://' in host:
            host = host.split('://')[1].split('/')[0].split(':')[0]

        scanner = NetworkScanner(host, args.timeout)
        all_findings.extend(scanner.scan())

    # Generate and print report
    report = generate_report(all_findings, args.output)
    print(report)

    # Exit with error code if critical findings
    critical_count = sum(1 for f in all_findings if f.severity == 'CRITICAL')
    if critical_count > 0:
        sys.exit(1)


if __name__ == "__main__":
    main()
